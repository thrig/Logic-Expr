# -*- Perl -*-
#
# logic expression related routines. see Logic::Expr::Parser for how the
# expressions are built

package Logic::Expr 0.01;
use 5.26.0;
use Data::Dumper;    # DBG
use Object::Pad;
class Logic::Expr;

use constant { TRUE => 1, FALSE => 0 };

# 'atoms' contains a name to reference to a slot in 'bools' mapping;
# 'bools' is an array of unique atoms in an expression for easy
# iteration by the "solutions" method; 'expr' is the parse tree of the
# expression as probably generated by Logic::Expr::Parser. though
# mutators are provided be aware that hand editing these structures may
# break things. in particular 'bools' must be modified in-place to not
# break the scalar references to the array slots
has $atoms :param :mutator;
has $bools :param :mutator;
has $expr  :param :mutator;

# brute force all possible boolean states for an expression
method solutions()
{
    my @orig;    # to leave bools unmolested afterwards
    for my $x (@$bools) {
        push @orig, $x;
        $x = TRUE;
    }
    my @solutions = [ [ $bools->@* ], _solve($expr) ];
    # the reverse index ordering is to match that of the tables in the
    # logic book (TT, TF, FT, FF)
    my $i = $bools->$#*;
    while ( $i >= 0 ) {
        if ( $bools->[$i] ) {
            $bools->[$i] = FALSE;
            push @solutions, [ [ $bools->@* ], _solve($expr) ];
            $i = $bools->$#*;
        } else {
            $bools->[ $i-- ] = TRUE;
        }
    }
    for my $x (@$bools) { $x = shift @orig }
    return \@solutions;
}

# solve the expression using the current state in bools
method solve() { _solve($expr) }

sub _solve ($ptr)
{
    my $rt = ref $ptr;
    if ( $rt eq 'SCALAR' ) {    # lookup an atom
        return $$ptr;
    } elsif ( $rt eq 'ARRAY' ) {    # operators
        my $op = $ptr->[0];
        if ( $op eq '!' ) {         # NOT
            return !_solve( $ptr->[1] );
        } elsif ( $op eq '&' ) {    # AND - TFFF
            for my $x ( $ptr->@[ 1 .. $#$ptr ] ) {
                return FALSE unless _solve($x);
            }
            return TRUE;
        } elsif ( $op eq 'v' ) {    # OR - TTTF
            for my $x ( $ptr->@[ 1 .. $#$ptr ] ) {
                return TRUE if _solve($x);
            }
            return FALSE;
        }
        die "TODO OP $op FOR ", Dumper $ptr;
    }
    die "unknown entity '$rt' in expression tree ", Dumper $ptr;
}

1;
__END__

=head1 NAME

Logic::Expr - logical expression parsing and related routines

=head1 SYNOPSIS

  use Logic::Expr::Parser;

  my $le = Logic::Expr::Parser->new->from_string('Xv~Y');

  ...

=head1 DESCRIPTION

L<Logic::Expr::Parser> parses logic expressions and returns a
L<Logic::Expr> object, which in turn has various methods for solving all
possible solutions, etc.

=head1 METHODS

=over 4

...

=back

=head1 BUGS

None known.

=head1 SEE ALSO

There are various other logic modules on CPAN.

"A Modern Formal Logic Primer". Paul Teller. 1989.

https://tellerprimer.ucdavis.edu/

=head1 COPYRIGHT AND LICENSE

Copyright 2022 Jeremy Mates

This program is distributed under the (Revised) BSD License:
L<https://opensource.org/licenses/BSD-3-Clause>

=cut
